{
  "name": "beefy",
  "version": "1.1.0",
  "description": "local development server that aims to make using browserify fast and fun",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/beefy.git"
  },
  "keywords": [
    "simplehttpserver",
    "browserify"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "dependencies": {
    "response-stream": "0.0.0",
    "colors": "~0.6.0-1",
    "through": "~2.2.0",
    "nopt": "~2.1.1",
    "mime": "~1.2.9",
    "sse-stream": "0.0.4",
    "open": "0.0.3",
    "portfinder": "~0.2.1",
    "script-injector": "~0.1.0",
    "chokidar": "0.8.1",
    "ignorepatterns": "1.0.1"
  },
  "bin": {
    "beefy": "./bin/beefy"
  },
  "preferGlobal": true,
  "readme": "# beefy\n\na local development server designed to work with browserify.\n\nit:\n\n* can live reload your browser when your code changes (if you want)\n* works with whatever version of browserify; globally installed or \n  locally installed to `node_modules/browserify`.\n* will spit compile errors out into the browser so you don't have that\n  1-2 seconds of cognitive dissonance and profound ennui that follows\n  refreshing the page only to get a blank screen.\n* will spit out a default `index.html` for missing routes so you don't\n  need to even muck about with HTML to get started\n* serves up static files with grace and aplomb (and also appropriate\n  mimetypes)\n* makes it easy to sanity check your [testling ci tape test suite](http://npm.im/tape/).\n* loves you, unconditionally\n\n## how do I get it?\n\n`npm install -g beefy`; and if you want to always have a browserify available\nfor beefy to use, `npm install -g browserify`.\n\n## usage\n\n```javascript\n$ cd directory/you/want/served\n$ beefy path/to/thing/you/want/browserified.js PORT -- [browserify args]\n```\n\n#### `path/to/file.js`\n\nthe path to the file you want browserified. can be just a normal node module.\nyou can also alias it: `path/to/file.js:bundle.js` if you want -- so all requests\nto `bundle.js` will browserify `path/to/file.js`. this is helpful for when you're\nwriting `gh-pages`-style sites that already have an index.html, and expect the\nbundle to be pregenerated and available at a certain path.\n\n#### `--browserify command`\n#### `--bundler command`\n\nuse `command` instead of `browserify` or `./node_modules/.bin/browserify`.\n\n~~in theory, you could even get this working with `r.js`, but that would probably\nbe scary and bats would fly out of it. but it's there if you need it!~~ if you want\nto use `r.js` with beefy, you'll need a config that can write the resulting bundle\nto stdout, and you can run beefy with `beefy :output-url.js --bundler r.js -- -o config.js`.\n\n#### `--live`\n\nenable live reloading. this'll start up a sideband server and an `fs` watch on\nthe current working directory -- if you save a file, your browser will refresh.\n\nif you're not using the generated index file, put the following script tag above\nall of your other JS:\n\n```html\n    <script src=\"/-/live-reload.js\"></script>\n```\n\n#### `--cwd dir`\n\nserve files as if running from `dir`.\n\n#### `--debug=false`\n\nturn off browserify source map output. by default, beefy automatically inserts\n`-d` into the browserify args -- this turns that behavior off.\n\n#### `--open`\n\nautomatically discover a port and open it using your default browser.\n\n## api\n\nbeefy exports one function which returns a http server created from `http.createServer()`\n\n### beefy(cwd, browserify_path, browserify_args, entry_points, live_reload, log, custom_handler)\n\n* `cwd` (string) root folder beefy uses for serving content. this folder is also watched if the `live_reload` parameter is set.\n* `browserify_path` (string) command to execute when browserifying the code. use `'browserify'` for standard behavior.\n* `browserify_args` (array of strings) arguments to the browserify command. use e.g. `[ '-d' ]` for debug mode.\n* `entry_points` (object) dictionary for your entry points and corresponding file to browserify. see example below.\n* `live_reload` (boolean) enable live reload if set\n* `log` (function) optional logging callback. see signature below.\n* `custom_handler` (function) optional custom request handler. return falsy in handler to delegate back to beefy.\n\n```js\nvar beefy = require('beefy')\nvar entry_points = { 'bundle.js': 'path/to/some/js/file.js' }\nvar server = beefy('path/to/wwwroot', 'browserify', [ '-d' ], entry_points, true, log,\n                   custom_handler)\nserver.listen(9966)\n\nfunction log(code, time, bytesize, logged_pathname, color) {}\n\nfunction custom_handler(req, resp) {\n  if (req.url == '/foo') {\n    // custom handling of '/foo'\n    resp.end('bar\\n')\n    return true\n  }\n  // delegate back to beefy\n}\n\n```\n\nthe server object is patched with a `reload()` method which allows you to reload clients programmatically:\n\n```js\nvar watchr = require('watchr')\nwatchr.watch({\n    path: '/some/other/path/not/watched/by/beefy'\n  , listener: function (event, file, stat_now, stat_then) {\n      // do stuff ..\n      server.reload()\n    }\n})\n\n```\n\n\n## the fake index\n\nby default, if you get a URL that doesn't exist (with an `Accept` header that has `html` in it someplace), you'll get the \"fake index.\" this page is setup so that\nit automatically includes both the live reload script (if it's enabled) **and** the\npath you want browserified. \n\n## license\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/beefy/issues"
  },
  "homepage": "https://github.com/chrisdickinson/beefy",
  "_id": "beefy@1.1.0",
  "_from": "beefy@"
}
